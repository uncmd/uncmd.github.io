<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="description" content="CLR via C#"><meta name="keywords" content="读书,笔记,C#"><meta name="author" content="睡五百年可好"><meta name="copyright" content="睡五百年可好"><meta name="theme-color" content="#0078E7"><title>CLR via C# | 睡五百年可好</title><link rel="shortcut icon" href="/favicon.png"><link rel="mask-icon" href="/favicon.png" color="#0078E7"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script id="yun-config">
    window.CONFIG = {"root":"/","title":"睡五百年可好","version":"0.7.1","anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true}};
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;family=Source+Code+Pro&amp;display=swap" media="none" onload="this.media='all'"><script src="//at.alicdn.com/t/font_1140697_rtqh36oinzl.js" async></script><div class="js-Pjax"></div><meta name="generator" content="Hexo 4.2.1"><link rel="stylesheet" href="/css/prism.css" type="text/css"></head><body><div class="container"><a class="sidebar-toggle sidebar-toggle-fixed hty-icon-button"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><aside class="sidebar"><script defer src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about" title="睡五百年可好"><img width="96" loading="lazy" src="/images/logo.jpg" alt="睡五百年可好"></a><div class="site-author-name"><a href="/about/">睡五百年可好</a></div><a class="site-name" href="/about/site.html">睡五百年可好</a><sub class="site-subtitle"></sub><div class="site-desciption">睡五百年可好</div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item site-state-posts"><a href="/archives" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">30</span></a></div><div class="site-state-item site-state-categories"><a href="/categories" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">7</span></a></div><div class="site-state-item site-state-tags"><a href="/tags" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">32</span></a></div><a class="site-state-item hty-icon-button" href="https://uncmd.github.io/doc-st/#!index.md" title="文档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-settings-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://wpa.qq.com/msgrd?v=3&amp;uin=1951765200&amp;site=qq&amp;menu=yes" title="QQ" target="_blank" style="color:#12B7F5"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-qq-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/uncmd" title="GitHub" target="_blank" style="color:#181717"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:wenjunpeng@chinasie.com" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://weibo.com/3007178515" title="微博" target="_blank" style="color:#E6162D"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-weibo-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/albums/" title="我的相册" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-gallery-line"></use></svg></a></div></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#第Ⅰ部分-CLR基础"><span class="toc-number">1.</span> <span class="toc-text">第Ⅰ部分 CLR基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#第-1-章-CLR的执行模型"><span class="toc-number">1.1.</span> <span class="toc-text">第 1 章 CLR的执行模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CLR是公共语言运行时-Common-Language-Runtime"><span class="toc-number">1.1.1.</span> <span class="toc-text">CLR是公共语言运行时(Common Language Runtime)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#通用类型系统-Common-Type-System-CTS"><span class="toc-number">1.1.2.</span> <span class="toc-text">通用类型系统(Common Type System, CTS)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#公共语言规范-Common-Language-Specification-CLS"><span class="toc-number">1.1.3.</span> <span class="toc-text">公共语言规范(Common Language Specification, CLS)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第-2-章-生成、打包、部署和管理应用程序及类型"><span class="toc-number">1.2.</span> <span class="toc-text">第 2 章 生成、打包、部署和管理应用程序及类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#将类型生成到模块中"><span class="toc-number">1.2.1.</span> <span class="toc-text">将类型生成到模块中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#元数据概述"><span class="toc-number">1.2.2.</span> <span class="toc-text">元数据概述</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第-3-章-共享程序集和强命名程序集"><span class="toc-number">1.3.</span> <span class="toc-text">第 3 章 共享程序集和强命名程序集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#全局程序集缓存"><span class="toc-number">1.3.1.</span> <span class="toc-text">全局程序集缓存</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第Ⅱ部分-设计类型"><span class="toc-number">2.</span> <span class="toc-text">第Ⅱ部分 设计类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#第-4-章-类型基础"><span class="toc-number">2.1.</span> <span class="toc-text">第 4 章 类型基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#所有类型都从-System-Object-派生"><span class="toc-number">2.1.1.</span> <span class="toc-text">所有类型都从 System.Object 派生</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#类型转换"><span class="toc-number">2.1.2.</span> <span class="toc-text">类型转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#命名空间和程序集"><span class="toc-number">2.1.3.</span> <span class="toc-text">命名空间和程序集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#运行时的相互关系"><span class="toc-number">2.1.4.</span> <span class="toc-text">运行时的相互关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第-5-章-基元类型、引用类型和值类型"><span class="toc-number">2.2.</span> <span class="toc-text">第 5 章 基元类型、引用类型和值类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#编程语言的基元类型"><span class="toc-number">2.2.1.</span> <span class="toc-text">编程语言的基元类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#引用类型和值类型"><span class="toc-number">2.2.2.</span> <span class="toc-text">引用类型和值类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第-6-章-类型和成员基础"><span class="toc-number">2.3.</span> <span class="toc-text">第 6 章 类型和成员基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第-7-章-常量和字段"><span class="toc-number">2.4.</span> <span class="toc-text">第 7 章 常量和字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第-8-章-方法"><span class="toc-number">2.5.</span> <span class="toc-text">第 8 章 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第-9-章-参数"><span class="toc-number">2.6.</span> <span class="toc-text">第 9 章 参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第-10-章-属性"><span class="toc-number">2.7.</span> <span class="toc-text">第 10 章 属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第-11-章-事件"><span class="toc-number">2.8.</span> <span class="toc-text">第 11 章 事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第-12-章-泛型"><span class="toc-number">2.9.</span> <span class="toc-text">第 12 章 泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第-13-章-接口"><span class="toc-number">2.10.</span> <span class="toc-text">第 13 章 接口</span></a></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://uncmd.github.io/books/CLR/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="睡五百年可好"><meta itemprop="description" content="CLR via C#"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="睡五百年可好"></span><header class="post-header"><h1 class="post-title" itemprop="name headline" style="color: undefined">CLR via C#<a class="post-edit-link" href="https://github.com/uncmd/uncmd.github.io/tree/hexo/source/_posts/books/CLR.md" target="_blank" title="编辑" rel="noopener"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-edit-line"></use></svg></a></h1><div class="post-meta"><div class="post-time" style="display:block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="创建时间：2020-05-20 19:33:40" itemprop="dateCreated datePublished" datetime="2020-05-20T19:33:40+00:00">2020-05-20</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="修改时间：2020-08-27 15:12:48" itemprop="dateModified" datetime="2020-08-27T15:12:48+00:00">2020-08-27</time></div><span class="post-count"><span class="post-symbolcount"><span class="post-meta-item-icon" title="本文字数"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-file-word-line"></use></svg></span> <span title="本文字数">12k</span><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="阅读时长"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-timer-line"></use></svg></span> <span title="阅读时长">22 分钟</span></span></span><span class="leancloud_visitors" id="/books/CLR/" data-flag-title="CLR via C#"><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="阅读次数"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-eye-line"></use></svg> <span class="leancloud-visitors-count"></span></span></span><div class="post-classify"><span class="post-category"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span> <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category" href="/categories/%E9%82%A3%E4%BA%9B%E5%B9%B4%E7%AB%8B%E7%9A%84Flag/" itemprop="url" rel="index"><span itemprop="text">那些年立的Flag</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag" href="/tags/%E8%AF%BB%E4%B9%A6/"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">读书</span></a><a class="tag" href="/tags/%E7%AC%94%E8%AE%B0/"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">笔记</span></a><a class="tag" href="/tags/C/"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">C#</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content post-markdown"><p>本书针对CLR和.NET Framework 进行深入、全面的探讨，并结合实例介绍了如何利用它们进行设计、开发和调试。</p>
<p><a href="https://uncmd.github.io/books/CLR/"><img src="https://cdn.jsdelivr.net/gh/uncmd/MyResource/Hexo/images/books/clr.jpg" alt="" loading="lazy"></a></p>
<a id="more"></a>

<h2 id="第Ⅰ部分-CLR基础"><a href="#第Ⅰ部分-CLR基础" class="headerlink" title="第Ⅰ部分 CLR基础"></a>第Ⅰ部分 CLR基础</h2><h3 id="第-1-章-CLR的执行模型"><a href="#第-1-章-CLR的执行模型" class="headerlink" title="第 1 章 CLR的执行模型"></a>第 1 章 CLR的执行模型</h3><h4 id="CLR是公共语言运行时-Common-Language-Runtime"><a href="#CLR是公共语言运行时-Common-Language-Runtime" class="headerlink" title="CLR是公共语言运行时(Common Language Runtime)"></a>CLR是公共语言运行时(Common Language Runtime)</h4><p>可由多种编程语言使用的“运行时”，核心功能（比如内存管理、程序集加载、安全性、异常处理和线程同步）可由面向CLR的所有语言使用。</p>
<p>可用支持CLR的任何编程语言创建源码文件，然后编译成托管模块，托管模块是PE32或PE32+(64位)文件(PE是Portable Executable可移植执行体的简称)，托管PE文件由四部分组成：</p>
<ul>
<li><p>PE32或PE32+头：标识文件类型(GUI CUI DLL)、生成时间</p>
</li>
<li><p>CLR头：CLR版本、入口方法元数据token、模块的元数据、资源、强名称</p>
</li>
<li><p>元数据：描述源代码中定义的类型和成员、描述源代码引用的类型和成员</p>
</li>
<li><p>IL：编译器生成的代码，运行时CLR将IL编译成本机CPU指令</p>
</li>
</ul>
<p>JIT(just-in-time)编译器将IL转换成本机(native)CPU指令</p>
<p>方法首次调用时会调用JITCompiler函数将IL代码转换成本机CPU指令，之后再次调用同一方法则会跳过JITCompiler函数，直接执行内存块中的代码。</p>
<h4 id="通用类型系统-Common-Type-System-CTS"><a href="#通用类型系统-Common-Type-System-CTS" class="headerlink" title="通用类型系统(Common Type System, CTS)"></a>通用类型系统(Common Type System, CTS)</h4><p>类型向应用程序和其他类型公开了功能，通过类型，用一种编程语言写的代码能与用另一种编程语言写的代码沟通。</p>
<p>一个类型可用包含零个或多个成员</p>
<ul>
<li><p>字段(Field)</p>
</li>
<li><p>方法(Method)</p>
</li>
<li><p>属性(Property)</p>
</li>
<li><p>事件(Event)</p>
</li>
</ul>
<p>类型可见性</p>
<ul>
<li><p>private：只能由同一个类中的其他成员访问</p>
</li>
<li><p>family(C# protected)：可由派生类型访问，不管是否在同一个程序集</p>
</li>
<li><p>family and assembly(C#未提供这种访问控制)：可由派生类型访问，必须在同一个程序集</p>
</li>
<li><p>assembly(C# internal)：可由同一程序集的任何代码访问</p>
</li>
<li><p>family or assembly(C# protected internal)：任何程序集的派生类型访问，也可由同一程序集的任何类型访问</p>
</li>
<li><p>public：可由任何程序集中的任何代码访问</p>
</li>
</ul>
<h4 id="公共语言规范-Common-Language-Specification-CLS"><a href="#公共语言规范-Common-Language-Specification-CLS" class="headerlink" title="公共语言规范(Common Language Specification, CLS)"></a>公共语言规范(Common Language Specification, CLS)</h4><p>它详细定义了一个最小功能集，任何编译器只有支持这个功能集，生成的类型才能兼容由其它符合CLS、面向CLR的语言生成的组件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/uncmd/MyResource/Hexo/images/books/clr1-6.jpg" alt="CLR" loading="lazy"></p>
<blockquote>
<p>每种语言都提供了CLR/CTS的一个子集以及CLS的一个超集(但不一定是同一个超集)</p>
</blockquote>
<h3 id="第-2-章-生成、打包、部署和管理应用程序及类型"><a href="#第-2-章-生成、打包、部署和管理应用程序及类型" class="headerlink" title="第 2 章 生成、打包、部署和管理应用程序及类型"></a>第 2 章 生成、打包、部署和管理应用程序及类型</h3><h4 id="将类型生成到模块中"><a href="#将类型生成到模块中" class="headerlink" title="将类型生成到模块中"></a>将类型生成到模块中</h4><pre><code>csc.exe /out:Program.exe /t:exe /r:MSCorLib.dll Program.cs</code></pre><p><strong>响应文件</strong></p>
<p>响应文件是包含一组编译器命令行开关的文本文件，扩展名为.rsp，在命令行中用@符号指定响应文件。CSC.exe运行是会在CSC.exe所在的目录查找全局CSC.rsp文件，相同开关优先级为命令行显示指定&gt;本地响应文件&gt;全局响应文件。</p>
<p>.NET Framework安装时会在%SystemRoot%\Microsoft .NET\Framework64\vX.X.X目录中安装默认全局CSC.rsp文件，如v4.0.30319版本CSC.rsp文件内容如下：</p>
<pre><code># This file contains command-line options that the C#
# command line compiler (CSC) will process as part
# of every compilation, unless the &quot;/noconfig&quot; option
# is specified. 

# Reference the common Framework libraries
/r:Accessibility.dll
/r:Microsoft.CSharp.dll
/r:System.Configuration.dll
/r:System.Configuration.Install.dll
/r:System.Core.dll
/r:System.Data.dll
/r:System.Data.DataSetExtensions.dll
/r:System.Data.Linq.dll
/r:System.Data.OracleClient.dll
/r:System.Deployment.dll
/r:System.Design.dll
/r:System.DirectoryServices.dll
/r:System.dll
/r:System.Drawing.Design.dll
/r:System.Drawing.dll
/r:System.EnterpriseServices.dll
/r:System.Management.dll
/r:System.Messaging.dll
/r:System.Runtime.Remoting.dll
/r:System.Runtime.Serialization.dll
/r:System.Runtime.Serialization.Formatters.Soap.dll
/r:System.Security.dll
/r:System.ServiceModel.dll
/r:System.ServiceModel.Web.dll
/r:System.ServiceProcess.dll
/r:System.Transactions.dll
/r:System.Web.dll
/r:System.Web.Extensions.Design.dll
/r:System.Web.Extensions.dll
/r:System.Web.Mobile.dll
/r:System.Web.RegularExpressions.dll
/r:System.Web.Services.dll
/r:System.Windows.Forms.Dll
/r:System.Workflow.Activities.dll
/r:System.Workflow.ComponentModel.dll
/r:System.Workflow.Runtime.dll
/r:System.Xml.dll
/r:System.Xml.Linq.dll</code></pre><p>指定/noconfig命令行开关，编译器将忽略本地和全局CSC.rsp文件</p>
<h4 id="元数据概述"><a href="#元数据概述" class="headerlink" title="元数据概述"></a>元数据概述</h4><p>PE文件中的元数据是由几个表构成的二进制数据块，有三种表，分别是定义表(definition table)、引用表(reference table)和清单表(mainfest table)</p>
<p>常用的元数据定义表</p>
<ul>
<li><p>ModuleDef：包含文件模块文件名称和扩展名（不含路径），以及模块版本ID（编译器创建的GUID）</p>
</li>
<li><p>TypeDef：模块定义的每个类型在这个表中都有一个记录项</p>
</li>
<li><p>MethodDef：模块定义的每个方法都在这个表中有一个记录项</p>
</li>
<li><p>FieldDef：模块定义的每个字段都在这个表中有一个记录项</p>
</li>
<li><p>ParamDef：模块定义的每个参数都在这个表中有一个记录项</p>
</li>
<li><p>PropertyDef：模块定义的每个属性都在这个表中有一个记录项</p>
</li>
<li><p>EventDef：模块定义的每个事件都在这个表中有一个记录项</p>
</li>
</ul>
<p>常用的元数据引用表</p>
<ul>
<li><p>AssemblyRef</p>
</li>
<li><p>ModuleRef</p>
</li>
<li><p>TypeRef</p>
</li>
<li><p>MemberRef</p>
</li>
</ul>
<p>可以用 ILDasm.exe（IL 反汇编器）查看元数据表</p>
<pre><code>ILDasm Program.exe</code></pre><h3 id="第-3-章-共享程序集和强命名程序集"><a href="#第-3-章-共享程序集和强命名程序集" class="headerlink" title="第 3 章 共享程序集和强命名程序集"></a>第 3 章 共享程序集和强命名程序集</h3><p>CLR支持两种程序集：弱命名程序集（weakly named assembly）和强命名程序集（strongly named assembly）</p>
<p>两者的区别在于，强命名程序集使用发布者的公钥/私钥进行了签名，这一对密钥允许对程序集进行唯一性标识、保护和版本控制。弱命名程序集只能以私有方式部署，强命名程序集即可私有部署，也可全局部署。</p>
<p>强命名程序集使用以下四个特性唯一标识：文件名（不计扩展名）、版本号、语言文化、公钥</p>
<p>使用SN.exe获取密钥，命令行开关都区分大小写。</p>
<pre class=" language-bash"><code class="language-bash">SN -k MyCompany.snk</code></pre>
<p>这告诉SN.exe创建 MyCompany.snk 文件，文件中包含二进制形式的公钥和私钥。</p>
<h4 id="全局程序集缓存"><a href="#全局程序集缓存" class="headerlink" title="全局程序集缓存"></a>全局程序集缓存</h4><p>由多个应用程序访问的程序集必须放到公认的目录，而且CLR在检测到对该程序集的引用时，必须知道检查该目录。这个公认位置就是<strong>全局程序集缓存(Global Assembly Cache, GAC)</strong>，一般在以下目录：</p>
<pre><code>%SystemRoot%\Microsoft.NET\Assembly</code></pre><p>永远不要将程序集文件手动复制到GAC目录，安装强命名程序集最常用的工具是 GACUtil.exe。建议进行私有而不是全局部署。</p>
<p>CSC.exe 会尝试按顺序在以下目录查找程序集</p>
<ul>
<li><p>工作目录</p>
</li>
<li><p>CSC.exe 所在的目录，目录中还包含 CLR 的各种 DLL 文件</p>
</li>
<li><p>使用 /lib 编译器开关指定的任何目录</p>
</li>
<li><p>使用 LIB 环境变量指定的任何目录</p>
</li>
</ul>
<p>.NET Framework 程序集：生成程序集时从 编译器/CLR 目录加载，运行时从 GAC 加载</p>
<h2 id="第Ⅱ部分-设计类型"><a href="#第Ⅱ部分-设计类型" class="headerlink" title="第Ⅱ部分 设计类型"></a>第Ⅱ部分 设计类型</h2><h3 id="第-4-章-类型基础"><a href="#第-4-章-类型基础" class="headerlink" title="第 4 章 类型基础"></a>第 4 章 类型基础</h3><ul>
<li><p>所有类型都从 System.Object 派生</p>
</li>
<li><p>类型转换</p>
</li>
<li><p>命名空间和程序集</p>
</li>
<li><p>运行时的相互关系</p>
</li>
</ul>
<h4 id="所有类型都从-System-Object-派生"><a href="#所有类型都从-System-Object-派生" class="headerlink" title="所有类型都从 System.Object 派生"></a>所有类型都从 System.Object 派生</h4><p>System.Object 类提供了以下4中公共实例方法</p>
<ul>
<li><p>Equals 如果对象具有相同的值，则返回 true。</p>
</li>
<li><p>GetHashCode 返回对象的值的哈希码。</p>
</li>
<li><p>ToString 默认返回类型的完整名称（this.GetType().FullName）。</p>
</li>
<li><p>GetType 返回从 <code>Type</code> 派生的一个类型的实例，指出调用 GetType 的那个对象是什么类型。</p>
</li>
</ul>
<p>此外，从 System.Object 派生的类型能访问如下受保护的方法</p>
<ul>
<li><p>MemberwiseClone 这个非虚方法创建类型的新实例，并将新对象的实例字段设与this对象的实例字段完全一致，返回对新实例的引用。</p>
</li>
<li><p>Finalize 在对象的内存被实际回收之前，会调用这个虚方法。</p>
</li>
</ul>
<p>CLR要求所有对象都用new操作符创建，以下是 new 操作符所做的事情</p>
<ul>
<li><p>计算类型及其所有基类型中定义的所有实例字段需要的字节数。</p>
</li>
<li><p>从托管堆中分配类型要求的字节数，从而分配对象的内存，分配的所有字节都设为零(0)。</p>
</li>
<li><p>初始化对象的“类型对象指针”和“同步块索引”成员。</p>
</li>
<li><p>调用类型的实例构造器，传递在 new 调用中指定的实参</p>
</li>
</ul>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>CLR 最重要的特性之一就是类型安全</p>
<p>is 操作符检查对象是否兼容于指定类型</p>
<p>as 操作符返回转换后的对象，如果不能转换则返回 null</p>
<h4 id="命名空间和程序集"><a href="#命名空间和程序集" class="headerlink" title="命名空间和程序集"></a>命名空间和程序集</h4><p><strong>命名空间</strong>对相关类型进行逻辑分组，使名称变得更长，更可能具有唯一性。</p>
<p>命名空间和程序集不一定相关，不同程序集可能存在相同名称空间。</p>
<h4 id="运行时的相互关系"><a href="#运行时的相互关系" class="headerlink" title="运行时的相互关系"></a>运行时的相互关系</h4><p>线程创建时会分配到1MB的栈，栈空间用于向方法传递实参，方法内部定义的局部变量也在栈上。</p>
<h3 id="第-5-章-基元类型、引用类型和值类型"><a href="#第-5-章-基元类型、引用类型和值类型" class="headerlink" title="第 5 章 基元类型、引用类型和值类型"></a>第 5 章 基元类型、引用类型和值类型</h3><ul>
<li><p>编程语言的基元类型</p>
</li>
<li><p>引用类型和值类型</p>
</li>
<li><p>值类型的装箱和拆箱</p>
</li>
<li><p>对象哈希码</p>
</li>
<li><p>dynamic 基元类型</p>
</li>
</ul>
<h4 id="编程语言的基元类型"><a href="#编程语言的基元类型" class="headerlink" title="编程语言的基元类型"></a>编程语言的基元类型</h4><p>编译器直接支持的数据类型称为<strong>基元类型</strong>(primitive type)。基元类型直接映射到Framework 类库(FCL)中存在的类型。</p>
<p>例如，C#的 <code>int</code> 直接映射到 <code>System.Int32</code> 类型。</p>
<p>C#编译器支持与类型转换、字面值以及操作符有关的模式。只有在转换“安全”的时候，C#才允许隐式转换，“安全”是指不会发生数据丢失的情况。</p>
<p>C#总是对转换结果进行截断，而不进行向上取整。</p>
<p>CLR提供add/add.ovf, sub/sub.ovf, mul/mul.ovf和conv/conv.ovf IL指令，前者不执行溢出检查，后者在发生溢出时抛出 <code>System.OverflowException</code> 异常。</p>
<p>C#溢出检查默认关闭，编译器的 <code>/checked+</code> 开关全局控制是否溢出检查，<code>checked</code> 和 <code>uncheck</code> 操作符局部控制是否溢出检查，如：</p>
<pre class=" language-csharp"><code class="language-csharp">UInt32 invalid <span class="token operator">=</span> <span class="token keyword">unchecked</span><span class="token punctuation">(</span><span class="token punctuation">(</span>UInt32<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// OK</span>

Byte b <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
b <span class="token operator">=</span> <span class="token keyword">checked</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Byte<span class="token punctuation">)</span> <span class="token punctuation">(</span>b <span class="token operator">+</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 抛出 OverflowException 异常</span>

<span class="token keyword">checked</span><span class="token punctuation">{</span>
  Byte b <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
  b <span class="token operator">=</span> <span class="token keyword">checked</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Byte<span class="token punctuation">)</span> <span class="token punctuation">(</span>b <span class="token operator">+</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<h4 id="引用类型和值类型"><a href="#引用类型和值类型" class="headerlink" title="引用类型和值类型"></a>引用类型和值类型</h4><p>CLR 支持<strong>引用类型</strong>和<strong>值类型</strong>。引用类型总是从托管堆分配，C#的 <code>new</code> 操作符返回对象内存地址，使用引用类型必须留意性能问题</p>
<ul>
<li><p>内存必须从托管堆分配</p>
</li>
<li><p>堆上分配的每个对象都有一些额外成员，这些成员必须初始化</p>
</li>
<li><p>对象中的其它字节（为字段而设）总是设为零</p>
</li>
<li><p>从托管堆分配对象时，可能强制执行一次垃圾回收</p>
</li>
</ul>
<p>值类型的实例一般在线程栈上分配，派生自 <code>System.ValueType</code>，所有值类型都隐式密封，目的是防止将值类型用作其它引用类型或值类型的基类型。</p>
<h3 id="第-6-章-类型和成员基础"><a href="#第-6-章-类型和成员基础" class="headerlink" title="第 6 章 类型和成员基础"></a>第 6 章 类型和成员基础</h3><h3 id="第-7-章-常量和字段"><a href="#第-7-章-常量和字段" class="headerlink" title="第 7 章 常量和字段"></a>第 7 章 常量和字段</h3><h3 id="第-8-章-方法"><a href="#第-8-章-方法" class="headerlink" title="第 8 章 方法"></a>第 8 章 方法</h3><h3 id="第-9-章-参数"><a href="#第-9-章-参数" class="headerlink" title="第 9 章 参数"></a>第 9 章 参数</h3><h3 id="第-10-章-属性"><a href="#第-10-章-属性" class="headerlink" title="第 10 章 属性"></a>第 10 章 属性</h3><h3 id="第-11-章-事件"><a href="#第-11-章-事件" class="headerlink" title="第 11 章 事件"></a>第 11 章 事件</h3><h3 id="第-12-章-泛型"><a href="#第-12-章-泛型" class="headerlink" title="第 12 章 泛型"></a>第 12 章 泛型</h3><h3 id="第-13-章-接口"><a href="#第-13-章-接口" class="headerlink" title="第 13 章 接口"></a>第 13 章 接口</h3></div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>睡五百年可好</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="http://uncmd.github.io/books/CLR/" title="CLR via C#">http://uncmd.github.io/books/CLR/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> 许可协议。</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/share/git/" rel="prev" title="git使用技巧"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">git使用技巧</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/life/book/" rel="next" title="读书笔记"><span class="post-nav-text">读书笔记</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div id="comment"><div class="comment-tooltip text-center"><span>若您无 GitHub 账号，可直接在下方匿名评论。</span><br><span>若您想及时得到回复提醒，建议跳转 GitHub Issues 评论。</span><br><span>若没有本文 Issue，您可以使用 Comment 模版新建。</span><br><a class="hty-button hty-button--raised" id="github-issues" href="https://github.com/uncmd/uncmd.github.io/issues?q=is:issue+CLR via C#" target="_blank" rel="noopener">GitHub Issues</a></div><div class="comment-container" id="valine-container"></div><script src="https://cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script><script>function initValine() {
  setTimeout(() => {
    new Valine({
      el: "#valine-container",
      appId: '0npISzkBAUkOmtYd8T40Nb87-gzGzoHsz',
      appKey: 'Kel97lPyFOFKrs3lN2MefL0P',
      placeholder: '快来评论耶✌',
      path: window.location.pathname,
      avatar: '[object Object]',
      meta: ["nick","mail","link"],
      pageSize: 10,
      lang: 'zh-cn',
      visitor: true,
      highlight: true,
      recordIP: true,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: null,
      enableQQ: true,
      requiredFields: [],
    });
  }, 1000);
}
initValine();</script></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2020 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> 睡五百年可好</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v4.2.1</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v0.7.1</span></div><div class="live_time"><span>本博客已萌萌哒地运行</span><span id="display_live_time"></span><span class="moe-text">(●'◡'●)</span><script>function blog_live_time() {
  window.setTimeout(blog_live_time, 1000);
  const start = new Date('2020-05-12T00:00:00');
  const now = new Date();
  const timeDiff = (now.getTime() - start.getTime());
  const msPerMinute = 60 * 1000;
  const msPerHour = 60 * msPerMinute;
  const msPerDay = 24 * msPerHour;
  const passDay = Math.floor(timeDiff / msPerDay);
  const passHour = Math.floor((timeDiff % msPerDay) / 60 / 60 / 1000);
  const passMinute = Math.floor((timeDiff % msPerHour) / 60 / 1000);
  const passSecond = Math.floor((timeDiff % msPerMinute) / 1000);
  display_live_time.innerHTML = " " + passDay + " 天 " + passHour + " 小时 " + passMinute + " 分 " + passSecond + " 秒";
}
blog_live_time();
</script></div></footer><a class="hty-icon-button" id="goUp" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a></div><script defer src="/js/hexo-theme-yun.js"></script></body></html>